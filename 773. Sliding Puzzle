class Solution {
public:
    int slidingPuzzle(vector<vector<int>>& board) {
        vector<vector<int>> adj={
            {1,3},{0,4,2},{1,5},{0,4},{3,1,5},{2,4}
        }; //vector的二维数组，可以这样定义
        string target="123450";
        string cur="";
        for(int i=0;i<board.size();++i){
            for(int j=0;j<board[i].size();++j){
                cur+=(board[i][j]+'0');
            }
        }
        
        unordered_set<string> us;
        queue<string> q;
        
        q.push(cur);
        us.insert(cur);
        
        int step=0;
        while(!q.empty()){
            int remain=q.size();
            for(int i=0;i<remain;++i){
                string tmp=q.front();q.pop();
                if(target==tmp){
                    return step;
                }
                us.insert(tmp);
                int idx=0;
                for(;idx<6;++idx){
                    if(tmp[idx]=='0'){
                        break;
                    }
                }
                vector<int> nei=adj[idx];
                for(int nei_idx: nei){
                    string next=tmp;
                    swap(next[nei_idx],next[idx]);//字符串也可以swap
                    if(us.find(next)==us.end()){
                        //us.insert(tmp); 不能在这，这个地方tmp字符串，还没有进行处理（即判断是否达到目标）
                        q.push(next);
                    }
                }
            }
            step++;
        }
        return -1;
    }
};
=====================================================================
773. Sliding Puzzle
On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.
The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].
Given the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.
